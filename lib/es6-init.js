"use strict";

var _electron = require("electron");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _electronCompile = require("electron-compile");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function findPackageJson(initScript) {
  if (initScript === '/' || initScript.match(/^[A-Za-z]:$/)) {
    throw new Error("Can't find package.json");
  } // Walk up the parent directories until we find package.json. Make sure that
  // we're not actually stumbling upon a parent npm package


  var ret = _path["default"].join(initScript, 'package.json');

  if (_fs["default"].statSyncNoException(ret) && !_path["default"].resolve(_path["default"].dirname(ret), '..').match(/[\\\/]node_modules$/i)) {
    return ret;
  }

  return findPackageJson(_path["default"].dirname(initScript));
}
/**
 * Some debugger environment reconstruct process argument and inject args ignoring original order,
 * extract to find out right path for init script.
 *
 */


function getInitScriptPath() {
  var rawArgv = process.argv.filter(function (x) {
    return x.indexOf("--inspect=") === -1 && x.indexOf("--debug-brk");
  })[2];
  return _path["default"].resolve(rawArgv);
}

function main() {
  var initScript = getInitScriptPath();
  var packageJson = findPackageJson(initScript);

  var appPath = _path["default"].dirname(packageJson);

  var packageJsonData = JSON.parse(_fs["default"].readFileSync(packageJson, 'utf8'));

  _electron.app.setName(packageJsonData.productName || packageJsonData.name);

  _electron.app.setVersion(packageJsonData.version);

  _electron.app.setAppPath(appPath); // Reconstitute the original arguments


  var args = process.argv.slice(2);
  process.argv = [process.argv[0]].concat(args); //passthrough electron-compile command args if it's specified

  var parsedArgs = require('yargs').alias('c', 'cachedir').alias('s', 'sourcemapdir').argv;

  (0, _electronCompile.init)(_path["default"].dirname(packageJson), initScript, null, parsedArgs.c || null, parsedArgs.s || null);
}

main();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lczYtaW5pdC5qcyJdLCJuYW1lcyI6WyJmaW5kUGFja2FnZUpzb24iLCJpbml0U2NyaXB0IiwibWF0Y2giLCJFcnJvciIsInJldCIsInBhdGgiLCJqb2luIiwiZnMiLCJzdGF0U3luY05vRXhjZXB0aW9uIiwicmVzb2x2ZSIsImRpcm5hbWUiLCJnZXRJbml0U2NyaXB0UGF0aCIsInJhd0FyZ3YiLCJwcm9jZXNzIiwiYXJndiIsImZpbHRlciIsIngiLCJpbmRleE9mIiwibWFpbiIsInBhY2thZ2VKc29uIiwiYXBwUGF0aCIsInBhY2thZ2VKc29uRGF0YSIsIkpTT04iLCJwYXJzZSIsInJlYWRGaWxlU3luYyIsImFwcCIsInNldE5hbWUiLCJwcm9kdWN0TmFtZSIsIm5hbWUiLCJzZXRWZXJzaW9uIiwidmVyc2lvbiIsInNldEFwcFBhdGgiLCJhcmdzIiwic2xpY2UiLCJjb25jYXQiLCJwYXJzZWRBcmdzIiwicmVxdWlyZSIsImFsaWFzIiwiYyIsInMiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxTQUFTQSxlQUFULENBQXlCQyxVQUF6QixFQUFxQztBQUNuQyxNQUFJQSxVQUFVLEtBQUssR0FBZixJQUFzQkEsVUFBVSxDQUFDQyxLQUFYLENBQWlCLGFBQWpCLENBQTFCLEVBQTJEO0FBQ3pELFVBQU0sSUFBSUMsS0FBSixDQUFVLHlCQUFWLENBQU47QUFDRCxHQUhrQyxDQUtuQztBQUNBOzs7QUFDQSxNQUFJQyxHQUFHLEdBQUdDLGlCQUFLQyxJQUFMLENBQVVMLFVBQVYsRUFBc0IsY0FBdEIsQ0FBVjs7QUFDQSxNQUFJTSxlQUFHQyxtQkFBSCxDQUF1QkosR0FBdkIsS0FBK0IsQ0FBQ0MsaUJBQUtJLE9BQUwsQ0FBYUosaUJBQUtLLE9BQUwsQ0FBYU4sR0FBYixDQUFiLEVBQWdDLElBQWhDLEVBQXNDRixLQUF0QyxDQUE0QyxzQkFBNUMsQ0FBcEMsRUFBeUc7QUFDdkcsV0FBT0UsR0FBUDtBQUNEOztBQUVELFNBQU9KLGVBQWUsQ0FBQ0ssaUJBQUtLLE9BQUwsQ0FBYVQsVUFBYixDQUFELENBQXRCO0FBQ0Q7QUFFRDs7Ozs7OztBQUtBLFNBQVNVLGlCQUFULEdBQTZCO0FBQzNCLE1BQU1DLE9BQU8sR0FBR0MsT0FBTyxDQUFDQyxJQUFSLENBQWFDLE1BQWIsQ0FBb0IsVUFBQ0MsQ0FBRDtBQUFBLFdBQU9BLENBQUMsQ0FBQ0MsT0FBRixtQkFBNEIsQ0FBQyxDQUE3QixJQUFrQ0QsQ0FBQyxDQUFDQyxPQUFGLGVBQXpDO0FBQUEsR0FBcEIsRUFBdUYsQ0FBdkYsQ0FBaEI7QUFDQSxTQUFPWixpQkFBS0ksT0FBTCxDQUFhRyxPQUFiLENBQVA7QUFDRDs7QUFFRCxTQUFTTSxJQUFULEdBQWdCO0FBQ2QsTUFBTWpCLFVBQVUsR0FBR1UsaUJBQWlCLEVBQXBDO0FBQ0EsTUFBTVEsV0FBVyxHQUFHbkIsZUFBZSxDQUFDQyxVQUFELENBQW5DOztBQUNBLE1BQU1tQixPQUFPLEdBQUdmLGlCQUFLSyxPQUFMLENBQWFTLFdBQWIsQ0FBaEI7O0FBQ0EsTUFBTUUsZUFBZSxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV2hCLGVBQUdpQixZQUFILENBQWdCTCxXQUFoQixFQUE2QixNQUE3QixDQUFYLENBQXhCOztBQUVBTSxnQkFBSUMsT0FBSixDQUFZTCxlQUFlLENBQUNNLFdBQWhCLElBQStCTixlQUFlLENBQUNPLElBQTNEOztBQUNBSCxnQkFBSUksVUFBSixDQUFlUixlQUFlLENBQUNTLE9BQS9COztBQUNBTCxnQkFBSU0sVUFBSixDQUFlWCxPQUFmLEVBUmMsQ0FVZDs7O0FBQ0EsTUFBTVksSUFBSSxHQUFHbkIsT0FBTyxDQUFDQyxJQUFSLENBQWFtQixLQUFiLENBQW1CLENBQW5CLENBQWI7QUFDQXBCLEVBQUFBLE9BQU8sQ0FBQ0MsSUFBUixHQUFlLENBQUNELE9BQU8sQ0FBQ0MsSUFBUixDQUFhLENBQWIsQ0FBRCxFQUFrQm9CLE1BQWxCLENBQXlCRixJQUF6QixDQUFmLENBWmMsQ0FjZDs7QUFDQSxNQUFNRyxVQUFVLEdBQUdDLE9BQU8sQ0FBQyxPQUFELENBQVAsQ0FBaUJDLEtBQWpCLENBQXVCLEdBQXZCLEVBQTRCLFVBQTVCLEVBQXdDQSxLQUF4QyxDQUE4QyxHQUE5QyxFQUFtRCxjQUFuRCxFQUFtRXZCLElBQXRGOztBQUNBLDZCQUFLVCxpQkFBS0ssT0FBTCxDQUFhUyxXQUFiLENBQUwsRUFBZ0NsQixVQUFoQyxFQUE0QyxJQUE1QyxFQUFrRGtDLFVBQVUsQ0FBQ0csQ0FBWCxJQUFnQixJQUFsRSxFQUF3RUgsVUFBVSxDQUFDSSxDQUFYLElBQWdCLElBQXhGO0FBQ0Q7O0FBRURyQixJQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwIH0gZnJvbSAnZWxlY3Ryb24nO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtpbml0fSBmcm9tICdlbGVjdHJvbi1jb21waWxlJztcblxuZnVuY3Rpb24gZmluZFBhY2thZ2VKc29uKGluaXRTY3JpcHQpIHtcbiAgaWYgKGluaXRTY3JpcHQgPT09ICcvJyB8fCBpbml0U2NyaXB0Lm1hdGNoKC9eW0EtWmEtel06JC8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBwYWNrYWdlLmpzb25cIik7XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBwYXJlbnQgZGlyZWN0b3JpZXMgdW50aWwgd2UgZmluZCBwYWNrYWdlLmpzb24uIE1ha2Ugc3VyZSB0aGF0XG4gIC8vIHdlJ3JlIG5vdCBhY3R1YWxseSBzdHVtYmxpbmcgdXBvbiBhIHBhcmVudCBucG0gcGFja2FnZVxuICBsZXQgcmV0ID0gcGF0aC5qb2luKGluaXRTY3JpcHQsICdwYWNrYWdlLmpzb24nKVxuICBpZiAoZnMuc3RhdFN5bmNOb0V4Y2VwdGlvbihyZXQpICYmICFwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHJldCksICcuLicpLm1hdGNoKC9bXFxcXFxcL11ub2RlX21vZHVsZXMkL2kpKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHJldHVybiBmaW5kUGFja2FnZUpzb24ocGF0aC5kaXJuYW1lKGluaXRTY3JpcHQpKTtcbn1cblxuLyoqXG4gKiBTb21lIGRlYnVnZ2VyIGVudmlyb25tZW50IHJlY29uc3RydWN0IHByb2Nlc3MgYXJndW1lbnQgYW5kIGluamVjdCBhcmdzIGlnbm9yaW5nIG9yaWdpbmFsIG9yZGVyLFxuICogZXh0cmFjdCB0byBmaW5kIG91dCByaWdodCBwYXRoIGZvciBpbml0IHNjcmlwdC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldEluaXRTY3JpcHRQYXRoKCkge1xuICBjb25zdCByYXdBcmd2ID0gcHJvY2Vzcy5hcmd2LmZpbHRlcigoeCkgPT4geC5pbmRleE9mKGAtLWluc3BlY3Q9YCkgPT09IC0xICYmIHguaW5kZXhPZihgLS1kZWJ1Zy1icmtgKSlbMl07XG4gIHJldHVybiBwYXRoLnJlc29sdmUocmF3QXJndik7XG59XG5cbmZ1bmN0aW9uIG1haW4oKSB7XG4gIGNvbnN0IGluaXRTY3JpcHQgPSBnZXRJbml0U2NyaXB0UGF0aCgpO1xuICBjb25zdCBwYWNrYWdlSnNvbiA9IGZpbmRQYWNrYWdlSnNvbihpbml0U2NyaXB0KTtcbiAgY29uc3QgYXBwUGF0aCA9IHBhdGguZGlybmFtZShwYWNrYWdlSnNvbik7XG4gIGNvbnN0IHBhY2thZ2VKc29uRGF0YSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VKc29uLCAndXRmOCcpKTtcblxuICBhcHAuc2V0TmFtZShwYWNrYWdlSnNvbkRhdGEucHJvZHVjdE5hbWUgfHwgcGFja2FnZUpzb25EYXRhLm5hbWUpO1xuICBhcHAuc2V0VmVyc2lvbihwYWNrYWdlSnNvbkRhdGEudmVyc2lvbik7XG4gIGFwcC5zZXRBcHBQYXRoKGFwcFBhdGgpO1xuXG4gIC8vIFJlY29uc3RpdHV0ZSB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG4gIGNvbnN0IGFyZ3MgPSBwcm9jZXNzLmFyZ3Yuc2xpY2UoMik7XG4gIHByb2Nlc3MuYXJndiA9IFtwcm9jZXNzLmFyZ3ZbMF1dLmNvbmNhdChhcmdzKTtcblxuICAvL3Bhc3N0aHJvdWdoIGVsZWN0cm9uLWNvbXBpbGUgY29tbWFuZCBhcmdzIGlmIGl0J3Mgc3BlY2lmaWVkXG4gIGNvbnN0IHBhcnNlZEFyZ3MgPSByZXF1aXJlKCd5YXJncycpLmFsaWFzKCdjJywgJ2NhY2hlZGlyJykuYWxpYXMoJ3MnLCAnc291cmNlbWFwZGlyJykuYXJndjtcbiAgaW5pdChwYXRoLmRpcm5hbWUocGFja2FnZUpzb24pLCBpbml0U2NyaXB0LCBudWxsLCBwYXJzZWRBcmdzLmMgfHwgbnVsbCwgcGFyc2VkQXJncy5zIHx8IG51bGwpO1xufVxuXG5tYWluKClcbiJdfQ==